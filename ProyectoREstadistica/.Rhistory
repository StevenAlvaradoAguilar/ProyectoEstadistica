ifelse(aire$Month == 7,"Julio",
ifelse(aire$Month == 8, "Agosto","Septiembre")
)
)
)
aire$Mes <- factor(aire$Mes, levels = c("Mayo","Junio","Julio","Agosto","Septiembre"))
ggplot(aire, aes(Mes, Ozone)) +
geom_boxplot(alpha = 0.4, color = "dodgerblue4", outlier.shape = 19)
aire$Mes <- ifelse(aire$Month == 5, "Mayo",
ifelse (aire$Month == 6, "Junio",
ifelse(aire$Month == 7,"Julio",
ifelse(aire$Month == 8, "Agosto","Septiembre")
)
)
)
aire$Mes <- factor(aire$Mes, levels = c("Mayo","Junio","Julio","Agosto","Septiembre"))
aire$Mes <- ifelse(aire$Month == 5, "Mayo",
ifelse (aire$Month == 6, "Junio",
ifelse(aire$Month == 7,"Julio",
ifelse(aire$Month == 8, "Agosto","Septiembre")
)
)
)
aire$Mes <- factor(aire$Mes, levels = c("Mayo","Junio","Julio","Agosto","Septiembre"))
ggplot(aire, aes(Mes, Ozone)) +
geom_boxplot(alpha = 0.4, color = "dodgerblue4", outlier.shape = 19)
ggplot(aire, aes(Month,Ozone )) +
geom_boxplot(alpha = 0.4, color = "blue", aes(group = cut_width(Month, 1)))
ggplot(aire, aes(Month,Ozone )) +
geom_boxplot(alpha = 0.4, color = "blue", aes(group = cut_width(Month, 1)))
aire$Mes <- ifelse(aire$Month == 5, "Mayo",
ifelse (aire$Month == 6, "Junio",
ifelse(aire$Month == 7,"Julio",
ifelse(aire$Month == 8, "Agosto","Septiembre")
)
)
)
aire$Mes <- factor(aire$Mes, levels = c("Mayo","Junio","Julio","Agosto","Septiembre"))
ggplot(aire, aes(Mes, Ozone)) +
geom_boxplot(alpha = 0.4, color = "dodgerblue4", outlier.shape = 19)
ggplot(aire, aes(Mes, Ozone)) +
geom_boxplot(alpha = 0.4, color = "dodgerblue4", outlier.shape = 19, outlier.color = "red", aes(fill = Month)) +
geom_point(alpha = 0.2)
ggplot(aire, aes(Month, Ozone)) +
geom_boxplot(alpha = 0.4, color = "dodgerblue4", outlier.shape = 19, outlier.color = "red", aes(fill = Mes)) +
geom_point(alpha = 0.2)
ggplot(aire, aes(Mes, Ozone)) +
geom_boxplot(alpha = 0.4, color = "dodgerblue4", outlier.shape = 19, outlier.color = "red", aes(fill = Month))+
labs(title = "Media diaria de Ozono en ppm, por mes", subtitle = "Roosevel Island según mes, del 1 de mayo al 30 de septiembre 1973", y = "Ozono")
# g1 es una variables que almacena la primera capa del gráfico a crear
g1 <- ggplot(aire, aes(Mes, Ozone))
g1 +
geom_violin(aes(fill = Month, alpha = 0.3))
g1 +
geom_jitter(width = 0.3, alpha = 0.4) +
geom_violin(aes(fill = Month, alpha = 0.3))
g1 +
geom_jitter(width = 0.3, alpha = 0.4) +
geom_violin(aes(fill = Month, alpha = 0.3))
g1 +
geom_jitter(width = 0.3, alpha = 0.4) +
geom_boxplot(alpha = 0.4, color = "blue") +
geom_violin(aes(alpha = 0.3, fill = Month))
est <- aire %>%
group_by(Mes) %>%
summarise(media = mean(Ozone),
n = n(),
de = sd(Ozone),
ee = de/sqrt(n()),
li = media - 1.96*ee,
ls = media +1.96*ee
)
est
g1 +
geom_jitter(width = 0.3, alpha = 0.4) +
geom_boxplot() +
geom_violin(aes(alpha = 0.3, fill = Month)) +
theme_minimal() +
geom_point(data = est, aes(Mes, media)) +
geom_errorbar(data = est, aes(Mes, media, ymin = li, ymax = ls), width = 0.2, color ="red")
ggplot(aire, aes(Mes)) +
geom_bar(aes(fill = Month))
mescont <- aire %>%
group_by(Mes) %>%
summarize(conteo = n() )
ggplot(mescont, aes(Mes, conteo)) +
geom_col(fill = "steelblue", width = 0.015) +
geom_point(color = "darkorange", size = 5) +
geom_text(aes(label = conteo), size = 2)
ggplot(aire, aes(Month)) +
geom_bar(aes(fill = Mes))
mescont <- aire %>%
group_by(Mes) %>%
summarize(conteo = n() )
ggplot(mescont, aes(Mes, conteo)) +
geom_col(fill = "steelblue", width = 0.015) +
geom_point(color = "darkorange", size = 5) +
geom_text(aes(label = conteo), size = 2)
graf1 <- ggplot(aire, aes(Month)) +
geom_bar(aes(fill = Mes))
ggplotly(graf1)
lollipops <- ggplot(mescont, aes(Mes, conteo)) +
geom_col(fill = "steelblue", width = 0.015) +
geom_point(color = "darkorange", size = 5) +
geom_text(aes(label = conteo), size = 2)
ggplotly(lollipops)
str(diamantes)
diamantesdata <- diamantes
ggplot(data = diamantesdata) +
geom_bar(mapping = aes(x = corte)) # aes: define una variable para la estética
diamantesgrupo <- diamantesdata %>%
group_by(corte) %>%
summarize(cantidad = n()
)
diamantesgrupo$proporcion <- diamantesgrupo$cantidad/sum(diamantesgrupo$cantidad)
diamantesgrupo <- diamantesdata %>%
group_by(corte) %>%
summarize(cantidad = n()
)
diamantesgrupo$proporcion <- diamantesgrupo$cantidad/sum(diamantesgrupo$cantidad)
ggplot(data = diamantesgrupo) +
geom_bar(mapping = aes(x = reorder(corte, cantidad), y = cantidad) ,stat="identity", position="dodge")
ggplot(data = diamantesgrupo) +
geom_bar(mapping = aes(x = reorder(corte, -cantidad), y = cantidad) ,stat="identity", position="dodge")
ggplot(data = diamantesgrupo) +
geom_bar(mapping = aes(x = reorder(corte, -proporcion), y = proporcion, group = 1) ,stat="identity", position="dodge")
ggplot(data = diamantesgrupo) +
geom_bar(mapping = aes(x = reorder(corte, -cantidad), y = cantidad, colour = corte) ,stat="identity", position="dodge")
ggplot(data = diamantesgrupo) +
geom_bar(mapping = aes(x = reorder(corte, -cantidad), y = cantidad, fill = corte) ,stat="identity", position="dodge")
ggplot(data = diamantesdata) +
geom_bar(mapping = aes(x = corte, fill = color))
ggplot(data = diamantesdata) +
geom_bar(mapping = aes(x = corte, fill = color), position = "jitter")
ggplot(data = diamantes) +
geom_bar(mapping = aes(x = corte, fill = color), position = "fill")
ggplot(data = diamantes) +
geom_bar(mapping = aes(x = corte, fill = corte), position = "dodge") +
coord_flip()
bar <- ggplot(data = diamantes) +
geom_bar(
mapping = aes(x = corte, fill = corte),
show.legend = FALSE,
width = 1
) +
theme(aspect.ratio = 1) +
labs(x = NULL, y = NULL)
bar
bar +
coord_flip()
bar +
coord_polar()
bar +
coord_flip()
bar +
coord_polar()
bar2 <- ggplot(data = diamantes) +
geom_bar(mapping = aes(x = corte, fill = color),
show.legend = F,
width = 0.75) +
theme(aspect.ratio = 1) +
labs(x = NULL, y = NULL)
bar + coord_flip()
bar2 +
coord_polar()
install.packages("ymlthis")
aire <- na.omit(airquality)
vis_dat(aire)
library(visdat) # Paquete con varias herramientas para visualizar datos
library(DataExplorer) #Para usar la función plot_missing
library(mosaicData) # Paquete que contiene bases de datos
library(ggplot2) # paquete graficador de alto desempeño
library(colorspace) # Paleta de colores
library(dplyr) #para usar funciones de ordenamiento, selección, agrupación
library(GGally)
library(tidyr) # para usar la función drop_na
library(PerformanceAnalytics)
library(psych)
library(ggraph)
library(plotly) #para crear gráficos interactivos
library(datos) # paquete que contienes diferentes bases de datos
knitr::opts_chunk$set(echo = TRUE)
?airquality
head(airquality)
summary(airquality)
str(airquality)
vis_dat(airquality)
vis_guess(airquality)
vis_miss(airquality)
plot_missing(airquality) # Me indica si tenemos datos en blanco y me da una recomendación, que en este caso dice que es "Good y Ok", lo cual no es mucho problema
# Use ?plot_missing() si desea conocer más sobre esta función
aire <- na.omit(airquality)
vis_dat(aire)
abline(v = mu,lwd = 2)
abline(v = mu,lwd = 2)
plot(1, type = "n", xlim = c(-0.8, 0.8), ylim = c(0, 200), xlab = "Valores",
ylab = "Repeticiones", main = "")
seg.int <- function(i){
color = "light blue"
if((mu < ICs[1,i]) | (mu > ICs[2,i])){
color = "red"
}
segments(ICs[1,i], i, ICs[2,i], i, col = color, lwd = 2)
}
head(sapply(1:200, FUN = seg.int), 0)
abline(v = mu,lwd = 2)
library(visdat) # Paquete con varias herramientas para visualizar datos
library(DataExplorer) #Para usar la función plot_missing
library(mosaicData) # Paquete que contiene bases de datos
library(ggplot2) # paquete graficador de alto desempeño
library(colorspace) # Paleta de colores
library(dplyr) #para usar funciones de ordenamiento, selección, agrupación
library(GGally)
library(tidyr) # para usar la función drop_na
library(PerformanceAnalytics)
library(psych)
library(ggraph)
library(plotly) #para crear gráficos interactivos
library(datos) # paquete que contienes diferentes bases de datos
library(epitools)
library(EnvStats)
library(stests)
library(PASWR2)
str(airquality)
aire <- na.omit(airquality)
vis_dat(aire)
aire <- na.omit(airquality)
vis_dat(aire)
aire <- na.omit(airquality)
vis_dat(aire)
ggplot(aire, aes(Month))
ggplot(aire, aes(Month))
ggplot(aire, aes(Month,Ozone )) +
geom_boxplot(alpha = 0.4, color = "blue", aes(group = cut_width(Month, 1)))
aire$Mes <- ifelse(aire$Month == 5, "Mayo",
ifelse (aire$Month == 6, "Junio",
ifelse(aire$Month == 7,"Julio",
ifelse(aire$Month == 8, "Agosto","Septiembre")
)
)
)
aire$Mes <- factor(aire$Mes, levels = c("Mayo","Junio","Julio","Agosto","Septiembre"))
ggplot(aire, aes(Mes, Ozone)) +
geom_boxplot(alpha = 0.4, color = "dodgerblue4", outlier.shape = 19, outlier.color = "red", aes(fill = Month)) +
geom_point(alpha = 0.2)
g1 +
geom_jitter(width = 0.3, alpha = 0.4) +
geom_violin(aes(fill = Month, alpha = 0.3))
g1 +
geom_jitter(width = 0.3, alpha = 0.4) +
geom_violin(aes(fill = Month, alpha = 0.3))
g1 +
geom_violin(aes(fill = Month, alpha = 0.3))
# g1 es una variables que almacena la primera capa del gráfico a crear
g1 <- ggplot(aire, aes(Mes, Ozone))
g1 +
geom_violin(aes(fill = Month, alpha = 0.3))
g1 +
geom_jitter(width = 0.3, alpha = 0.4) +
geom_violin(aes(fill = Month, alpha = 0.3))
g1 +
geom_jitter(width = 0.3, alpha = 0.4) +
geom_boxplot(alpha = 0.4, color = "blue") +
geom_violin(aes(alpha = 0.3, fill = Month))
# Se planta la semilla
set.seed(45)
# Se establecen los índices para la muestra
flores.elegidas.setosa <- sample(1:50, 40, replace = TRUE)
flores.elegidas.versicolor <- sample(51:100, 40, replace = TRUE)
# Se extraen las muestras
muestra.setosa <- iris[flores.elegidas.setosa, ]
muestra.versicolor <- iris[flores.elegidas.versicolor, ]
# Se aplica la prueba de hipótesis
t.test(muestra.setosa$Petal.Length, muestra.versicolor$Petal.Length,
alternative = "two.sided")
prop.test(x, n, p =..., alternative=..., conf.level=...)
# Se revisa primeramente la comporisión de la tabla birthwt
str(birthwt)
head(birthwt, 5)
b <- birthwt
# Se calcula las etiquetas de las madres de cada raza
madres.raza.blanca <- rownames(birthwt[birthwt$race == 1, ])
madres.raza.negra <- rownames(birthwt[birthwt$race == 2, ])
# Se eligen las muestras de tamaño 50 para cada raza
set.seed(2000)
madres.elegidas.blanca <- sample(madres.raza.blanca, 50, replace = TRUE)
madres.elegidas.negra <- sample(madres.raza.negra, 50, replace = TRUE)
muestra.madres.raza.blanca <- birthwt[madres.elegidas.blanca, ]
muestra.madres.raza.negra <- birthwt[madres.elegidas.negra, ]
# Se calculan cuantas madres fumadoras hay en cada una de las muestras usando la funci[on table y las almacenamos en una nueva variable
table(muestra.madres.raza.blanca$smoke)
table(muestra.madres.raza.negra$smoke)
# número de madres fumadoras de raza blanca
x.blanca <- table(muestra.madres.raza.blanca$smoke)[2]
# número de madres fumadoras de raza negra
x.negra <- table(muestra.madres.raza.negra$smoke)[2]
# Se hace el contraste de hipótesis
prop.test(c(x.blanca, x.negra), c(50, 50))
prop.test(x, n, p =..., alternative=..., conf.level=...)
tiempo <- c(12, 13, 13, 14, 14, 14, 15, 15, 16, 17,
17, 18, 18, 19, 19, 25, 25, 26, 27, 30,
33, 34, 35, 40, 40, 51, 51, 58, 59, 83)
# Varianza muestral
n <- 30
s.tiempo <- var(tiempo)
# Calcule los valores de la distribución o cuantiles
alpha <- 0.05
chi2.izq <- qchisq(1-alpha/2, n-1)
chi2.der <- qchisq(alpha/2, n-1)
# IC para la varianza:
ICvar <- c((n-1)*s.tiempo/chi2.izq, (n-1)*s.tiempo/chi2.der)
ICvar
# IC para la desviación estándar
sqrt(ICvar)
# IC para la varianza
varTest(tiempo, conf.level = 0.95)$conf.int
# IC para la varianza
varTest(tiempo, conf.level = 0.95)$conf.int
# IC para la desviación estándar
sqrt(ICvar)
# IC para la varianza
varTest(tiempo, conf.level = 0.95)$conf.int
# Se define la función IC.t que nos da el IC para la media dada para una muestra
IC.t <- function(X, confianza = 0.95){t.test(X,
conf.level = confianza)$conf.int}
ICs <- apply(muestras, FUN = IC.t, MARGIN = 2)
# Conteo de aciertos
Aciertos <- length(which((mu >= ICs[1,]) & (mu <= ICs[2,])))
Aciertos
# Se genera la población de valores
set.seed(2020)
valores.poblacion <- rnorm(10^7)
# Se calcula la media poblacional
mu <- mean(valores.poblacion)
# Se toman 200 muestras usando la función "replicate" de R, que permite ejecutar una misma función las veces que se le indique
muestras <- replicate(200, sample(valores.poblacion, 50, replace = TRUE))
str(muestras)
set.seed(1000)
muestra.iris <- sample(1:150,30,replace = TRUE)
long.petalo.muestra <- iris[muestra.iris, ]$Petal.Length
t.test(long.petalo.muestra,conf.level = 0.95)$conf.int
# IC para la varianza
varTest(tiempo, conf.level = 0.95)$conf.int
# IC para al desviación estándar
sqrt(varTest(tiempo, conf.level = 0.95)$conf.int)
# Se extraen la mediciones de sépalo de la muestra
amplitud.sepalo.muestra <- iris[flores.elegidas, ]$Sepal.Width
head(amplitud.sepalo.muestra, 10)
# Chunk 1
library(visdat) # Paquete con varias herramientas para visualizar datos
library(DataExplorer) #Para usar la función plot_missing
library(mosaicData) # Paquete que contiene bases de datos
library(ggplot2) # paquete graficador de alto desempeño
library(colorspace) # Paleta de colores
library(dplyr) #para usar funciones de ordenamiento, selección, agrupación
library(GGally)
library(tidyr) # para usar la función drop_na
library(PerformanceAnalytics)
library(psych)
library(ggraph)
library(plotly) #para crear gráficos interactivos
library(datos) # paquete que contienes diferentes bases de datos
library(epitools)
library(EnvStats)
library(stests)
library(PASWR2)
# Chunk 2: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 3
?airquality
# Chunk 4
head(airquality)
# Chunk 5
summary(airquality)
# Chunk 6
str(airquality)
# Chunk 7
vis_dat(airquality)
# Chunk 8
vis_guess(airquality)
# Chunk 9
vis_miss(airquality)
# Chunk 10
plot_missing(airquality) # Me indica si tenemos datos en blanco y me da una recomendación, que en este caso dice que es "Good y Ok", lo cual no es mucho problema
# Use ?plot_missing() si desea conocer más sobre esta función
# Chunk 11
aire <- na.omit(airquality)
vis_dat(aire)
# Chunk 12
set.seed(1012)
mu = 1.5; sigma = 1; alpha = 0.05
Poblacion = rnorm(10^6,mu,sigma)
# Chunk 13
ICZ <- function(x, sigma, alpha){
c(mean(x) - qnorm(1-alpha/2)*sigma/sqrt(length(x)),
mean(x) + qnorm(1-alpha/2)*sigma/sqrt(length(x)))}
# Chunk 14
set.seed(2)
muestra <- sample(Poblacion, 50, replace = T)
str(muestra)
# Chunk 15
is.vector(muestra)
# Chunk 16
M <- replicate(100, ICZ(sample(Poblacion, 50, replace = T), sigma, alpha))
head(M, 1)
# Chunk 17
plot(1:10, type = "n", xlim =c(1.2, 1.8), ylim = c(0, 100),
xlab = "Valores", ylab = "Replicaciones")
seg.int <- function(i){color = "grey";
if((mu< M[1,i]) | (mu > M[2,i])){color = "red"}
segments(M[1,i], i, M[2,i],i, col = color,lwd = 3)}
invisible(sapply(1:100, FUN = seg.int))
abline(v = mu,lwd = 3)
# Chunk 18
#install.packages("PASWR2", dependencies = T)
cisim(samples = 100, n = 30, parameter = 100, sigma = 10, conf.level = 0.90)
# Chunk 19
cisim(100, 50, 0.5, type = "Pi", conf.level = 0.92)
# Chunk 20
cisim(100, 30, 100, 10, type = "Var")
# Chunk 21
temperatura <- c(36,35,38,38,36,37,38,36,37,36,
37,37,34,38,35,37,36,36,34,38,
36,37,35,35,35,35,36,36,36,35,
36,35,34,34,37,37,35,36,34,36)
ICtemp <- ICZ(temperatura, sd(temperatura), 0.1)
ICtemp
# Chunk 22
## Función para calcular el tamaño de muestra "n"
n <- function(radio,sigma,alpha){
ceiling(((qnorm(alpha/2)*sigma)/radio)^2)}
n(0.05, sd(temperatura), 0.1)
# Chunk 23
set.seed(1000)
muestra.iris <- sample(1:150,30,replace = TRUE)
long.petalo.muestra <- iris[muestra.iris, ]$Petal.Length
t.test(long.petalo.muestra,conf.level = 0.95)$conf.int
# Chunk 24
# Se genera la población de valores
set.seed(2020)
valores.poblacion <- rnorm(10^7)
# Se calcula la media poblacional
mu <- mean(valores.poblacion)
# Se toman 200 muestras usando la función "replicate" de R, que permite ejecutar una misma función las veces que se le indique
muestras <- replicate(200, sample(valores.poblacion, 50, replace = TRUE))
str(muestras)
# Chunk 25
# Se define la función IC.t que nos da el IC para la media dada para una muestra
IC.t <- function(X, confianza = 0.95){t.test(X,
conf.level = confianza)$conf.int}
ICs <- apply(muestras, FUN = IC.t, MARGIN = 2)
# Conteo de aciertos
Aciertos <- length(which((mu >= ICs[1,]) & (mu <= ICs[2,])))
Aciertos
# Chunk 26
plot(1, type = "n", xlim = c(-0.8, 0.8), ylim = c(0, 200), xlab = "Valores",
ylab = "Repeticiones", main = "")
seg.int <- function(i){
color = "light blue"
if((mu < ICs[1,i]) | (mu > ICs[2,i])){
color = "red"
}
segments(ICs[1,i], i, ICs[2,i], i, col = color, lwd = 2)
}
head(sapply(1:200, FUN = seg.int), 0)
# Chunk 27
abline(v = mu,lwd = 2)
# Chunk 28
tiempo <- c(12, 13, 13, 14, 14, 14, 15, 15, 16, 17,
17, 18, 18, 19, 19, 25, 25, 26, 27, 30,
33, 34, 35, 40, 40, 51, 51, 58, 59, 83)
# Chunk 29
# Varianza muestral
n <- 30
s.tiempo <- var(tiempo)
# Calcule los valores de la distribución o cuantiles
alpha <- 0.05
chi2.izq <- qchisq(1-alpha/2, n-1)
chi2.der <- qchisq(alpha/2, n-1)
# IC para la varianza:
ICvar <- c((n-1)*s.tiempo/chi2.izq, (n-1)*s.tiempo/chi2.der)
ICvar
# Chunk 30
# IC para la desviación estándar
sqrt(ICvar)
# Chunk 31
# IC para la varianza
varTest(tiempo, conf.level = 0.95)$conf.int
# Chunk 32
# IC para al desviación estándar
sqrt(varTest(tiempo, conf.level = 0.95)$conf.int)
# Chunk 33
# Se extraen la mediciones de sépalo de la muestra
amplitud.sepalo.muestra <- iris[flores.elegidas, ]$Sepal.Width
head(amplitud.sepalo.muestra, 10)
# Se extraen la mediciones de sépalo de la muestra
amplitud.sepalo.muestra <- iris[flores.elegidas, ]$Sepal.Width
head(amplitud.sepalo.muestra, 10)
# Se calcula el IC de 95% para la varianza de las ampliudes de sépalo de los datos iris
varTest(amplitud.sepalo.muestra, conf.level = 0.95)$conf.int
# Se lee la base de datos desde el enlace y se almacena en datos
url <- 'https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo'
datos <- read.table(file = url, header = T)
#Se extraen datos de hombres y mujeres
hombres <- datos[datos$sexo == "Hombre", ]
mujeres <- datos[datos$sexo == "Mujer", ]
dim(hombres)
dim(mujeres)
str(hombres)
str(mujeres)
# Media de hombres menos media de mujeres
t.test(hombres$altura, mujeres$altura,conf.level = 0.95)$conf.int
